# NewProxy: New Proxy for Java

[中文](./README_CN.md)

![Gitter](https://img.shields.io/gitter/room/lamspace/newproxy)
[![License](https://img.shields.io/badge/license-Apache%202-4EB1BA.svg)](https://www.apache.org/licenses/LICENSE-2.0.html)
![Static Badge](https://img.shields.io/badge/NewProxy-New%20Proxy%20for%20Java-color=red)
![GitHub Repo stars](https://img.shields.io/github/stars/lamspace/newproxy)
![GitHub forks](https://img.shields.io/github/forks/lamspace/newproxy)
![GitHub Release](https://img.shields.io/github/v/release/lamspace/newproxy)
![Maven Central Version](https://img.shields.io/maven-central/v/io.github.lamspace/newproxy)

---

## What is it?

> **NewProxy** is an extension of **Proxy**, It is similar to **CGLIB**.
> But it is as fast as **CGLIB** as possible, even faster, simpler and smaller than **CGLIB**.

More details see [GitHub](https://github.com/LamSpace/newproxy-samples)
or [Gitee](https://gitee.com/LamTong/newproxy-samples).

---

## What does it do?

**NewProxy** is a tool to generate **dynamic proxy** for interfaces, and class also.

It follows the concept of JDK's built-in **Proxy** class for generating dynamic proxy classes,
which involves creating a proxy class for the target interfaces and then invoking its methods,
returning the results to the caller.
In contrast to the JDK's **Proxy** class, dynamic proxy class generated by **NewProxy** does not extend **NewProxy**
itself; instead, it merely implements the specified interfaces (including extra **InvocationDispatcher** interface)
and extend class, significantly reducing the complexity of the generated proxy classes.

Besides, **NewProxy** also supports generating dynamic proxy class for one class at most like **CGLIB** does.

**NewProxy** provides the following features:

* Generate dynamic proxy classes for public interfaces and class with **public final** modifiers.
* Generate dynamic proxy classes for non-public interfaces and class with *final* modifier.
* Check whether the target class if a dynamic proxy class or not.
* Check if the target object is an instance of a dynamic proxy class or not.
* Acquire the invocation interceptor instance of the target object if its class is a dynamic proxy class.

---

## Quick Start

It's straightforward to use **NewProxy** to generate dynamic proxy classes as it is to use **Proxy**.

First of all, you need to import the **NewProxy** library into your project.

```xml

<dependency>
    <groupId>io.github.lamspace</groupId>
    <artifactId>newproxy</artifactId>
    <version>${latest.version}</version>
</dependency>
```

### Case 1: Generate dynamic proxy class for only interface(s)

```java
public interface Foo {

    void foo();

}
```

Then you need to do as follows:

```java
import io.github.lamspace.newproxy.InvocationInterceptor;
import io.github.lamspace.newproxy.MethodDecorator;
import io.github.lamspace.newproxy.NewProxy;

public static void main(String[] args) {
    InvocationInterceptor interceptor = new InvocationInterceptor() {
        @Override
        public Object intercept(Object proxy, MethodDecorator method, Object[] args) {
            return method.invoke(proxy, fooImpl, args);
        }
    };
    Foo foo = (Foo) NewProxy.newProxyInstance(Foo.class.getClassLoader(), interceptor, null, null, Foo.class);
    foo.foo();
}
```

---

### Case 2: Generate dynamic proxy class for class with non-parameter constructor

```java
public class Bar {

    public void bar() {
        // ...
    }

}
```

```java
import io.github.lamspace.newproxy.InvocationInterceptor;
import io.github.lamspace.newproxy.MethodDecorator;
import io.github.lamspace.newproxy.NewProxy;

public static void main(String[] args) {
    InvocationInterceptor interceptor = new InvocationInterceptor() {
        @Override
        public Object intercept(Object proxy, MethodDecorator method, Object[] args) throws Throwable {
            return method.invoke(proxy, null, args);
        }
    };
    Bar bar = (Bar) NewProxy.newProxyInstance(Bar.class.getClassLoader(), interceptor, null, null, Bar.class);
    bar.bar();
}
```

### Case 3: Generate dynamic proxy class for class with parameterized constructor

```java
public class Bar {

    private final String s;

    public Bar(Strin s) {
        this.s = s;
    }

    public void bar() {
        //...
    }

}
```

```java
import io.github.lamspace.newproxy.InvocationInterceptor;
import io.github.lamspace.newproxy.MethodDecorator;

public static void main(String[] args) {
    InvocationInterceptor interceptor = new InvocationInterceptor() {
        @Override
        public Object intercept(Object proxy, MethodDecorator method, Object[] args) throws Throwable {
            return method.invoke(proxy, null, args);
        }
    };
    Bar bar = (Bar) NewProxy.newProxyInstance(Bar.class.getClassLoader(), interceptor, new Class<?>[]{String.class}, new Object[]{"Hello World!"}, Bar.class);
    bar.bar();
}
```

### Case 4: Generate dynamic proxy class for interfaces and class

...

---

## Underlying Support

**NewProxy** is built on top of the **Byte Code Engineering Library**
(simply called [BCEL](https://commons.apache.org/proper/commons-bcel/)).
More details can be found in the [BCEL](https://commons.apache.org/proper/commons-bcel/) official website.

---

## Prerequisites

At least JDK 8 is required.

---

## Contributing

Contributions are welcome! Do what you want to do with **Apache License 2.0**!
Please check [CONTRIBUTING](./CONTRIBUTING.md).

*Cheers!*

---
